
// configuration

value rectangles = 80000000;
value runs       = 10;
value subruns    = 100;

value x0     = 0.0;
value xN     = 16.0;
value result = 5706;

// constants

value single   = 0;
value threads  = Immutable [1, 2, 4, 8];
value nthreads = 4;

value section = (xN - x0) / rectangles;
value halfSection = section / 2.0;

// functions

// 5x^2 - 10x + 10
function f(x: Float): Float {
    return 5 * x * x - 10 * x + 10;
}

function calcSingle: Float {
    variable area = 0.0;
    for variable x = x0; x < rectangles; x = x + 1 {
        area = area + f(x * section + halfSection) * section;
    }
    return area;
}

function calcMulti(thread, threadRectangles: Integer): Float {
    value start: Float = thread * threadRectangles;
    value end: Float = start + threadRectangles; // TODO
    variable area = 0.0;
    for variable x = start; x < end; x = x + 1 {
        area = area + f(x * section + halfSection) * section;
    }
    return area;
}

// monitors

monitor Barrier {
    variable queue = ConditionQueue();
    variable current, counter: Integer;

    initializer(n: Integer) {
        current = 0;
        counter = n;
    }

    function synchronize {
        current = current + 1;
        wait for current == counter in queue;
        broadcast queue;
    }
}

monitor Area {
    variable area = 0.0;

    initializer {}

    function add(v: Float) {
        area = area + v;
    }

    function get: Float {
        return area;
    }
}

// main

function main {
    srand(93029);

    value partials = [[Float](runs) | i in 0...(nthreads + 1)];
    variable t: Float;

    // single
    for variable i = 0; i < runs; i = i + 1 {
        t = getTime();
        for variable j = 0; j < subruns; j = j + 1 {
            variable area = calcSingle();
            assert(Integer(area) == result, "calculation error (s)\n");
        }
        partials[single][i] = getTime() - t;
    }

    // multi
    for variable k = 0; k < nthreads; k = k + 1 {
        value threads = threads[k];
        value threadRectangles = rectangles / threads;
        for variable i = 0; i < runs; i = i + 1 {
            t = getTime();
            for variable j = 0; j < subruns; j = j + 1 {
                value area = Area();
                value barrier = Barrier(threads + 1);
                for variable x = 0; x < threads; x = x + 1 {
                    value thread = x;
                    spawn {
                        area.add(calcMulti(thread, threadRectangles));
                        barrier.synchronize();
                    }
                }
                barrier.synchronize();
                assert(
                    Integer(area.get()) == result,
                    "calculation error (m)\n"
                );
            }
            partials[k + 1][i] = getTime() - t;
        }
    }

    // stats
    value avg = [0.0 | i in 0...(nthreads + 1)];
    value min = [10000000000.0 | i in 0...(nthreads + 1)];
    value max = [0.0 | i in 0...(nthreads + 1)];
    variable x, diffmax, diffmin: Float;

    print("\n");
    print("\tRectangles: %d\n", rectangles);
    print("\tRuns: %d\n", runs);
    print("\tSubruns: %d\n", subruns);
    print("\n");

    for variable i = 0; i < (nthreads + 1); i = i + 1 {
        for variable j = 0; j < runs; j = j + 1 {
            x = partials[i][j];
            avg[i] = avg[i] + x;
            if x < min[i] { min[i] = x; }
            if x > max[i] { max[i] = x; }
        }
        avg[i] = avg[i] / runs;
        diffmax = max[i] - avg[i];
        diffmin = avg[i] - min[i];

        print("\t");
        if i == single {
            print("SINGLE");
        } else {
            print("MULTI (%d threads)", threads[i - 1]);
        }
        print("\n");
        print("\tAvg: %f sec\n", avg[i]);
        print("\tMax: %f sec (+%f)\n", max[i], diffmax);
        print("\tMin: %f sec (-%f)\n", min[i], diffmin);
        print("\t- %f%%\n", diffmin / avg[i] * 100);
        print("\t+ %f%%\n", diffmax / avg[i] * 100);
        print("\n");

        if i != single {
            value speedup = avg[single] / avg[i];
            print("\tSpeedup: %.2f\n", speedup);
            print("\tEfficiency: %.2f%%\n", speedup / threads[i - 1] * 100);
            print("\n");
        }
    }
}
