
// configuration
value size    = 10000;
value runs    = 10;
value subruns = 100;

value threads  = Immutable [1, 2, 4, 8];
value nthreads = 4;

// monitors

monitor Barrier {
    variable queue = ConditionQueue();
    variable current, counter: Integer;

    initializer(n: Integer) {
        current = 0;
        counter = n;
    }

    function synchronize {
        current = current + 1;
        wait for current == counter in queue;
        broadcast queue;
    }
}

monitor Array {
    variable n: Integer;
    variable array: [Float];

    initializer(size: Integer) {
        n = size;
        array = [Float](n);
    }

    function get(i: Integer): Float    { return array[i]; }
    function set(i: Integer, v: Float) { array[i] = v;    }
}

// functions

function main {
    srand(93029);

    value partials = [[Float](runs) | i in 0...(nthreads + 1)];
    variable t: Float;

    // memory
    t = getTime();
    value a = Immutable [(rand() / 1000000) as Float | i in 0...size * size];
    value b = Immutable [(rand() / 1000000) as Float | i in 0...size];
    // value a = Immutable [
    //     [(rand() / 1000000) as Float | j in 0...size]
    // | i in 0...size];
    value c = [Float](size);
    value m = Array(size);
    value memory = getTime() - t;

    // single
    for variable x = 0; x < runs; x = x + 1 {
        t = getTime();
        variable r: Float;
        variable ioff: Integer;
        for variable y = 0; y < subruns; y = y + 1 {
            // algorithm
            for variable i = 0; i < size; i = i + 1 {
                r = 0;
                ioff = i * size;
                for variable j = 0; j < size; j = j + 1 {
                    r = r + a[ioff + j] * b[j];
                }
                c[i] = r;
            }
        }
        partials[0][x] = getTime() - t;
    }

    // multi
    for variable k = 0; k < nthreads; k = k + 1 {
        for variable x = 0; x < runs; x = x + 1 {
            value threads = threads[k];
            value section = size / threads;
            t = getTime();
            for variable y = 0; y < subruns; y = y + 1 {
                // algorithm
                value barrier = Barrier(threads + 1);
                for variable i = 0; i < threads; i = i + 1 {
                    value thread = i;
                    spawn {
                        value start = thread * section;
                        value end = start + section;
                        variable r: Float;
                        variable ioff: Integer;
                        for variable i = start; i < end; i = i + 1 {
                            r = 0;
                            ioff = i * size;
                            for variable j = 0; j < size; j = j + 1 {
                                r = r + a[ioff + j] * b[j];
                            }
                            m.set(i, r);
                        }
                        barrier.synchronize();
                    }
                }
                barrier.synchronize();
            }
            partials[k + 1][x] = getTime() - t;
        }
    }

    // validating
    for variable i = 0; i < size; i = i + 1 {
        assert(c[i] == m.get(i), "c != m");
    }

    // stats
    value sz = nthreads + 1;
    value avg = [0.0 | i in 0...sz];
    value min = [10000000000.0 | i in 0...sz];
    value max = [0.0 | i in 0...sz];
    variable x, diffmax, diffmin: Float;

    print("\n");
    print("\tMemory: %f sec\n", memory);
    print("\n");
    print("\tSize: %d\n", size);
    print("\tRuns: %d\n", runs);
    print("\tSubruns: %d\n", subruns);
    print("\n");

    for variable i = 0; i < (nthreads + 1); i = i + 1 {
        for variable j = 0; j < runs; j = j + 1 {
            x = partials[i][j];
            avg[i] = avg[i] + x;
            if x < min[i] { min[i] = x; }
            if x > max[i] { max[i] = x; }
        }
        avg[i] = avg[i] / runs;
        diffmax = max[i] - avg[i];
        diffmin = avg[i] - min[i];

        print("\t");
        if i == 0 {
            print("SINGLE");
        } else {
            print("MULTI (%d threads)", threads[i - 1]);
        }
        print("\n");
        print("\tAvg: %f sec\n", avg[i]);
        print("\tMax: %f sec (+%f)\n", max[i], diffmax);
        print("\tMin: %f sec (-%f)\n", min[i], diffmin);
        print("\t- %f%%\n", diffmin / avg[i] * 100);
        print("\t+ %f%%\n", diffmax / avg[i] * 100);
        print("\n");

        if (i != 0) {
            value speedup = avg[0] / avg[i];
            value efficiency = speedup / threads[i - 1] * 100;
            print("\tSpeedup: %.2f\n", speedup);
            print("\tEfficiency: %.2f%%\n", efficiency);
            print("\n");
        }
    }
}
