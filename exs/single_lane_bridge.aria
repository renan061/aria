
function fakeWork {
	variable i = 0;
	while i < 10000000 {
		i = i + 1;
	}
}

monitor SingleLaneBridge {
	// ==================================================
	//
	//	Private
	//
	// ==================================================

	value wantsToGoLeftQueue = ConditionQueue();
	value wantsToGoRightQueue = ConditionQueue();

	value left = -1;
	value notraffic = 0;
	value right	= 1;

	variable direction = notraffic;

	// number of cars is the bridge
	variable cars = 0;
	// value maxcars = 2; // TODO

	private function notGoing(n: Integer): Boolean {
		return not (direction == n);
	}

	// ==================================================
	//
	//	Public
	//
	// ==================================================

	initializer {}

	function goLeft(id: Integer) {
		// if cars >= maxcars {
			// wait for notGoing(right) and cars == 0 in wantsToGoLeftQueue;
		// } else {
			wait for notGoing(right) in wantsToGoLeftQueue;
		// }
		direction = left;
		cars = cars + 1;
		fakeWork();
		print("Car %d entering <<<\n", id);
	}

	function goRight(id: Integer) {
		// if cars >= maxcars {
			// wait for notGoing(left) and cars == 0 in wantsToGoRightQueue;
		// } else {
			wait for notGoing(left) in wantsToGoRightQueue;
		// }
		
		direction = right;
		cars = cars + 1;
		fakeWork();
		print("Car %d entering >>>\n", id);
	}

	function leave(id: Integer) {
		print("Car %d leaving direction ", id);
		if direction == left		{ print("<<<"); }
		else if direction == right	{ print(">>>"); }
		print("\n");

		temp := direction;
		cars = cars - 1;
		if cars == 0 {
			direction = notraffic;
		}

		if temp == left {
			signal wantsToGoRightQueue;
		} else if temp == right {
			signal wantsToGoLeftQueue;
		} else {
			print("error\n");
		}
	}
}

function main {
	m := SingleLaneBridge();

	// Problemas: Não é possível ceder o lock no meio do método do monitor.
	// Alguma forma de deixar dois "carros" consumirem dentro do monitor
	// sem essa capacidade?

	variable i = 0;
	while i < 5 {
		id := i;
		spawn {
			m.goRight(id);
			// m.do(id);
			m.leave(id);
		}
		i = i + 1;
	}

	while i < 10 {
		id := i;
		spawn {
			m.goLeft(id);
			// m.do(id);
			m.leave(id);
		}
		i = i + 1;
	}

	// OBS: erro no LLVM provavelmente porque o spawn dentro do spawn não
	// captura o temporário do "m" direito. Ver escopo.

	// spawn {
	// 	variable i = 0;
	// 	while i < 5 {
	// 		id := i;
	// 		spawn {
	// 			m.goRight(id);
	// 			// m.do(id);
	// 			m.leave(id);
	// 		}
	// 		i = i + 1;
	// 	}
	// }
}
