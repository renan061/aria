/*
 *
 * Modified producer-consumer problem.
 * Resource is released only when all consumers "saw" it.
 * 
 */

monitor ModifiedProducerConsumer
{
	initializer(capacity Int) {
		isFullQueue = Queue()
		isEmptyQueue = Queue()
		everyoneConsumedValueQueue = Queue()

		values = [Int](capacity)
		// [ResourceIndex: [ConsumerID: Bool]]
		hasConsumedValue = [Int: [Int: Bool]]()
	}

	// Problems: Add new resource when not all consumers saw the last
	function add(value Int) {
		while isFull() wait in isFullQueue
		values = append(values, value)
		hasConsumedValue[lastIndex(values)] = [Int: Bool]()
		signal consumersAreOffSyncQueue
		signal isEmptyQueue
	}

	function remove(id Int) Char {
		while isEmptyFor(id) wait in isEmptyQueue
		while hasConsumedValue[lastIndex(values)][id] wait in consumersAreOffSyncQueue

		// Calculating how many have not yet consumed the value
		counter := 0
		for _, value in hasConsumedValue[lastIndex(values)] {
			if not value {
				counter = counter + 1
			}
		}

		if counter == 1 { // Only the current consumer is missing
			value = removeLast()
			deleteFromMap(hasConsumedValue, lastIndex(values))
			signal consumersAreOffSyncQueue
			signal isFullQueue
		} else {
			value = last(values)
			hasConsumedValue[lastIndex(values)][id] = true
		}

		return value
	}

	// ==================================================
	//
	//	Auxiliary
	//
	// ==================================================
	
	private values [Int]
	private hasConsumedValue [Int: Bool]

	private isFullQueue Queue
	private function isFull() Bool {
		return lenght(values) == capacity(values)
	}

	private isEmptyQueue Queue
	private function isEmptyFor(id Int) Bool {
		len := lenght(values)
		return (len == 0) or (len == 1 and hasConsumedValue[lastIndex(values)][id])
	}

	private consumersAreOffSyncQueue Queue
}


function main() {
	stack := ModifiedProducerConsumer(10)

	// Producers
	for i := 0; i < 3; i++ {
		spawn {
			for value := 0; true; value++ {
				stack.add(value)
			}
		}
	}

	// Consumers
	for i := 0; i < 3; i++ {
		spawn {
			while true {
				value := stack.remove(i) // ASK: Precisaria usar o 'i'
				print(value)
			}
		}
	}
}
