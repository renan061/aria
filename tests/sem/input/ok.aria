// Global value definition
value topValue1 = true;
value topValue2: String = "string";
value topValue3: Integer = 3.0;
value topValue4: Float = 4;

// Global function definition
function topFunction1 {}
function topFunction2: Boolean {}
function topFunction3(a: Boolean) {}
function topFunction4(a: Integer): Float {}
function topFunction5(a: String, b: Boolean, c: Integer) {}
function topFunction6(topA: Float, topB: String, topC: Boolean): Integer {}
function topFunction7(a, b, c: Float) {}
function topFunction8(a: String, b, c, d: Boolean): Integer {}
function topFunction9(a: Float, b, c: String, d: Boolean) {}

// Inside a common top level function
function foo {
	// Declaration of variables
	variable variable1: Boolean;
	variable variable2, variable3: Integer;
	variable variable4, variable5, variable6: Float;

	// Definition of variables and values (specific to blocks)
	syntacticSugarDefinition1 := false;
	syntacticSugarDefinition2 := foo(); // TODO: Should this be possible?
	value value1: Integer = 1;
	value value2 = 1;
	value value3: Float = 1;
	value value4 = 1;
	variable variable7: Float = 1.0;
	variable variable8 = 1.0;
	variable variable9: Float = 1;
	variable variable10 = 1;
	variable variable11 = foo();
	variable variable12: String = topValue2;

	// Simple statements

	// Assignment
	variable1 = value3 > 2;
	variable11 = foo(); // TODO: Should this be possible?

	// Basic function call
	foo();
	topFunction3(42 == 1.0);
	topFunction6(1, variable12, syntacticSugarDefinition1 or topFunction2());
	topFunction7(1, 2, 3);
	topFunction7(1.0, 2.0, topFunction4(3.0));

	// Return
	return;

	// Compound statements

	// If
	if true {}

	// If Else
	if false {} else {}

	// While
	while 1 > 2 {}

	// Spawn (TODO)

	// Block
	{
		a := 1;
		b := 2;
		variable c: Float;
		if a > b {
			c = a;
		} else {
			c = b;
		}
	}
}

// Others (monitor's and return) simple statements
monitor Monitor1 {
	value queue = "TODO"; // TODO: Condition Variables

	initializer {}

	function foo: String {
		// Return with expression
		return "string";
	}

	function bar {
		// While Wait
		while true wait in queue;

		// Signal
		signal queue;

		// Broadcast
		broadcast queue;
	}
}

monitor Monitor2 {
	initializer(n1, n2: Integer) {}

	function foo(n1, n2: Integer) {}
}

monitor Monitor3 {
	initializer(boolean: Boolean, float: Float, string: String) {}

	function foo(boolean: Boolean, float: Float, string: String) {}
}

function newMonitor3: Monitor3 {}

// Other function calls
function bar {
	// Constructor
	m1 := Monitor1();
	m2 := Monitor2(1, 2);
	m3 := Monitor3(true, 1.0, "aria");

	// Method
	m1.foo();
	m2.foo(1, 2.0);
	Monitor2(1, 2).foo(1.0, 0);
	m3.foo(false, 1, "aria-lang");
	newMonitor3().foo(true, 1.0, "aria language");
}

function expressions {
	// Literal Boolean
	variable a = true;
	a = false;

	// Literal Integer
	variable b = 0.0;
	b = 1000;

	// Literal Float
	value c = 0.0;

	// Literal String
	string1 := "c";
	string2 := "string";
	string3 := "s p a c e d s t r i n g";

	// Variable
	var := string1;

	// Function Call
	functionCall := newMonitor3();

	// Unary
	a = not true;
	b = -1;

	// Binary
	a = true or false;
	a = true and false;
	a = 1 == 1;
	a = 1 <= 1;
	a = 1 >= 1;
	a = 1 < 1;
	a = 1 > 1;

	// TODO: Casts and stuff
	// b = 1 + 1;
	// b = 1 - 1;
	// b = 1 * 1;
	// b = 1 / 1;
}

// Scoping (TODO)
function scoping {

}

// 	// TypeId
// 	variable type: Integer;

// 	// TypeArray
// 	variable type: [Integer];
// 	variable type: [[[Integer]]];

// 	// VariableIndexed
// 	var = a[1];
// 	var = a[1][1][1];
// 	var = foo()[1][1][1];
