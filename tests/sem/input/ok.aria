// Global value definition
value topValue1 = true;
value topValue2: String = "string";
value topValue3: Integer = 3.0;
value topValue4: Float = 4;

// Global function definition
function topFunction1 {}
function topFunction2: Boolean {}
function topFunction3(a: Boolean) {}
function topFunction4(a: Integer): Float {}
function topFunction5(a: String, b: Boolean, c: Integer) {}
function topFunction6(topA: Float, topB: String, topC: Boolean): Integer {}
function topFunction7(a, b, c: Float) {}
function topFunction8(a: String, b, c, d: Boolean): Integer {}
function topFunction9(a: Float, b, c: String, d: Boolean) {}
function topFunction10: [[[String]]] {}

monitor SpawnMonitor {
	initializer {}
}

// Inside a common top level function
function foo {
	// Indexed types
	variable indexed: [[[Integer]]];
	x := indexed[0];
	y := indexed[0][0];
	z := topFunction10()[0][0][0];

	// Declaration of variables
	variable variable1: Boolean;
	variable variable2, variable3: Integer;
	variable variable4, variable5, variable6: Float;
	// Testing insertion in the symbol table
	variable5 = 5.0;
	variable6 = 6.0;

	// Definition of variables and values (specific to blocks)
	syntacticSugarDefinition1 := false;
	// FIXME: Should this be possible?
	// foo is type Void
	syntacticSugarDefinition2 := foo();
	value value1: Integer = 1;
	value value2 = 1;
	value value3: Float = 1;
	value value4 = 1;
	variable variable7: Float = 1.0;
	variable variable8 = 1.0;
	variable variable9: Float = 1;
	variable variable10 = 1;
	variable variable11 = foo();
	variable variable12: String = topValue2;

	// Simple statements

	// Assignment
	variable1 = value3 > 2;
	variable11 = foo(); // FIXME: Should this be possible? (foo is type Void)
	// TODO: Not working
	// variable9 += 1;
	// variable9 -= 1;
	// variable9 *= 1;
	// variable9 /= 1;
	// variable9 = ((variable9: Integer) +:Integer (1: Integer));
	// variable9 = ((variable9: Integer) -:Integer (1: Integer));
	// variable9 = ((variable9: Integer) *:Integer (1: Integer));
	// variable9 = ((variable9: Integer) /:Integer (1: Integer));

	// Basic function call
	foo();
	topFunction3(42 == 1.0);
	topFunction6(1, variable12, syntacticSugarDefinition1 or topFunction2());
	topFunction7(1, 2, 3);
	topFunction7(1.0, 2.0, topFunction4(3.0));

	// Return
	return;

	// Compound statements

	// If
	if true {}

	// If Else
	if false {} else {}

	// While
	while 1 > 2 {}

	// Spawn
	spawnMonitor := SpawnMonitor();
	nestedSafeType := Immutable[Immutable[Immutable[Integer]]]();
	spawn {
		variable a = spawnMonitor;
		b := value1;
		c := nestedSafeType;
		variable x = 1;
		variable y = 2;
		x = y * 2 + value1;
		while x < 10 {
			x = x + 1;
		}
	}

	// Block
	{
		a := 1;
		b := 2;
		variable c: Float;
		if a > b {
			c = a;
		} else {
			c = b;
		}
	}
}

// Others (monitor's and return) simple statements
monitor Monitor1 {
	variable queue: ConditionQueue;

	initializer {
		return;
	}

	function foo: String {
		// Return with expression
		return "string";
	}

	function bar {
		// Wait for in
		wait for true in queue;

		// Signal
		signal queue;

		// Broadcast
		broadcast queue;
	}
}

monitor Monitor2 {
	initializer(n1, n2: Integer) {}

	function foo(n1, n2: Integer) {}
}

monitor Monitor3 {
	initializer(boolean: Boolean, float: Float, string: String) {}

	function foo(boolean: Boolean, float: Float, string: String) {}
}

function newMonitor3: Monitor3 {}

// Other function calls
function bar {
	// Constructor
	m1 := Monitor1();
	m2 := Monitor2(1, 2);
	m3 := Monitor3(true, 1.0, "aria");

	// Method
	m1.foo();
	m2.foo(1, 2.0);
	Monitor2(1, 2).foo(1.0, 0);
	m3.foo(false, 1, "aria-lang");
	newMonitor3().foo(true, 1.0, "aria language");
}

function expressions {
	// Literal Boolean
	variable a = true;
	a = false;

	// Literal Integer
	variable b = 0.0;
	b = 1000;

	// Literal Float
	value c = 0.0;

	// Literal String
	string1 := "c";
	string2 := "string";
	string3 := "s p a c e d s t r i n g";

	// Variable
	var := string1;

	// Function Call
	functionCall := newMonitor3();

	// Unary
	a = not true;
	b = -1;

	// Binary
	a = true or false;
	a = true and false;
	a = 1 == 1;
	a = 1 != 1;
	a = 1 <= 1;
	a = 1 >= 1;
	a = 1 < 1;
	a = 1 > 1;
	b = 1 + 1;
	b = 1.0 - 1;
	b = 1 * 1.0;
	b = 1.0 / 1.0;
}

// Scoping
function scoping {}

monitor Scoping1 {
	value a = [Integer]();

	private function scoping(a: Float): Float {
		return a * 2;
	}

	function bar {
		b := a[0];
		{
			b := scoping(1.0);
		}
	}
}

monitor Scoping2 {
	function foo {
		a := scoping();
	}
}
